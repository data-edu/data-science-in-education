# Walkthrough 8: Predicting students' final grades using supervised machine learning {#c14}

**Abstract** 

This chapter introduces a different type of statistical model that is increasingly common -- machine learning. Specifically, we focus on supervised machine learning, which involves, first, identifying an outcome (another name for a dependent variable), and then building (or training) a model to predict that outcome. Some supervised machine learning models are highly complex, while others are simple. To illustrate and gain experience training and interpreting a supervised machine learning model, this chapter involves predicting whether students will pass a class using a simple model -- a generalized linear model. The Open University Learning Analytics Dataset (OULAD) is used as an example of the type of data used in learning analytics. The tidymodels collection of packages is used to carry out each of the principal supervised machine learning steps. At the conclusion, ways to build more complex models are discussed.

## Topics emphasized

- Processing data
- Modeling data

## Functions introduced

- initial_split()
- training()
- testing()
- recipe()
- logistic_reg()
- set_model()
- set_mode()
- workflow()
- collect_predictions()
- collect_metrics()

## Vocabulary

- supervised machine learning
- training data
- testing data
- logistic regression
- classification
- predictions
- metrics

## Chapter overview

### Background

In a face-to-face classroom, an educator might count on behavioral cues to help them effectively deliver instruction. Online, educators do not readily have access to the behavioral cues essential for effective face-to-face instruction. For example, in a face-to-face classroom, cues such as a student missing class repeatedly or many students seeming distracted during a lecture can trigger a shift in the delivery of instruction. Many educators find themselves looking for ways to understand and support students online in the same way that face-to-face instructors would. Educational technology affords unique opportunities to support student success online because it provides new methods of collecting and storing data. 

Online learning management systems and Massive Open Online Courses (MOOCs) often automatically track several types of student interactions with the system and feed that data back to the course instructor. For example, an instructor might be able to quickly see how many students logged into their course on a certain day, or they might see how long students engaged with a posted video before pausing it or logging out. The collection of this data is met with mixed reactions from educators. Some are concerned that data collection in this manner is intrusive, but others see a new opportunity to support students in online contexts in new ways. As long as data are collected and utilized responsibly, data collection can support student success.

In this walkthrough, we examine the question, *How well can we predict students who are at risk of dropping a course?*

We focus on *predicting* an outcome--whether a student passes a course--more than *explaining* how variables relate to an outcome, such as how the amount of time students spend on the course relates to their final grade. We do so with a relatively simple machine learning algorithm, or model, a generalized linear regression model. 

### Data sources

We'll be using a widely-used data set in the learning analytics field: the [Open University Learning Analytics Dataset (OULAD)](https://analyse.kmi.open.ac.uk/open_dataset). The OULAD was created by learning analytics researchers at the United Kingdom-based Open University [@kuzilek2017]. It includes data from post-secondary learners participation in one of several Massive Open Online Courses (called *modules* in the OULAD).

The Open University Learning Analytics Dataset (OULAD) provides information for analyzing student outcomes in online learning environments. Many students successfully complete these courses, but not all do, highlighting the importance of identifying those who may be at risk. The dataset includes information on students' initial characteristics and their interactions within the course.

In this chapter, we draw on a widely-used data set in the learning analytics field: the Open University Learning Analytics Dataset (OULAD). The OULAD was created by learning analytics researchers at the United Kingdom-based Open University. It includes data from post-secondary learners participation in one of several Massive Open Online Courses (called modules in the OULAD). 

### Methods

#### Predictive analytics and machine learning

A buzzword in education software spheres these days is "predictive analytics". Administrators and educators alike are interested in applying the methods long utilized by marketers and other business professionals to try to determine what a person will want, need, or do next. "Predictive analytics" is a blanket term that can be used to describe any statistical approach that yields a prediction. We could ask a predictive model: "What is the likelihood that my cat will sit on my keyboard today?" and, given enough past information about your cat's computer-sitting behavior, the model could give you a probability of that computer-sitting happening today. Under the hood, some predictive models are not very complex. If we have an outcome with two possibilities, a logistic regression model could be fit to the data in order to help us answer the cat-keyboard question. In this chapter, we'll compare a machine learning model to another type of regression: multiple regression. We want to make sure to fit the simplest model as possible to our data. After all, the effectiveness in predicting the outcome is really the most important thing, not the fanciness of the model.

Data collection is an essential first step in any type of machine learning or predictive analytics. It is important to note here that machine learning only works effectively when (1) a person selects variables to include in the model that are anticipated to be related to the outcome and (2) a person correctly interprets the model's findings. 

There is an adage: "garbage in, garbage out". This holds true here. If we do not feel confident that the data we collected are accurate, we will not be able to be confident in our conclusions no matter what model we build. To collect good data, we must first clarify what it is that we want to know (i.e., what question are we really asking?) and what information we would need in order to effectively answer that question. Sometimes, people approach analysis from the opposite direction---they might look at the data they have and ask what questions could be answered based on that data. That approach is okay, as long as you are willing to acknowledge that sometimes the pre-existing dataset may *not* contain all the information you need, and you might need to go out and find additional information to add to your dataset to truly answer your question.

When people talk about "machine learning", you might get the image in your head of a desktop computer learning how to spell. You might picture your favorite social media site showing you advertisements that are just a little too accurate. At its core, machine learning is the process of "showing" your statistical model only some of the data at once and training the model to predict accurately on that training dataset (this is the "learning" part of machine learning). Then, the model as developed on the training data is shown new data---data you had all along, but hid from your computer initially---and you see how well the model that you developed on the training data performs on this new testing data. Eventually, you might use the model on entirely new data.  

## Load packages

As always, if you have not installed any of these packages before, do so first using the `install.packages()` function. For a description of packages and their installation, review the [Packages](#c06p) section of the [Foundational Skills](#c06) chapter.

```{r, message = FALSE, warning = FALSE}
# load the packages
library(tidyverse)
library(tidymodels)
```

#### Reading CSV Data

To begin, we will load student-level data using the `read_csv()` function. This dataset has undergone minimal preprocessing to help streamline our analysis -- it integrates information from three sources: `studentInfo`, `courses`, and `studentRegistration`.

Additionally, we will load an assessments dataset, which provides data on students' performance on various assessments throughout their courses.

```{r}
students <- read_csv("data/ml/oulad-students.csv")
assessments <- read_csv("data/ml/oulad-assessments.csv")
```

### Preprocessing and Feature Engineering

Our goal is to build a model that predicts whether a student is at risk of dropping out. We will handle some feature engineering directly, while moving a couple of preprocessing steps into the recipe to demonstrate how recipes work.

#### Step 1: Creating Outcome and Predictor Variables Outside the Recipe

To begin, we create the outcome variable (`pass`) and a factor variable for `disability` directly using `mutate()`:

```{r}
students <- students %>%
    mutate(pass = ifelse(final_result == "Pass", 1, 0)) %>%
    mutate(pass = as.factor(pass),
           disability = as.factor(disability))
```

We will also summarize assessment data to create a new predictor based on studentsâ€™ performance on assessments submitted early in the course. Specifically, we will calculate the mean weighted score of assessments submitted before the first half of assignment dates.

```{r}
code_module_dates <- assessments %>% 
    group_by(code_module, code_presentation) %>% 
    summarize(quantile_cutoff_date = quantile(date, probs = .5, na.rm = TRUE))

assessments_joined <- assessments %>% 
    left_join(code_module_dates) %>% 
    filter(date < quantile_cutoff_date) %>% 
    mutate(weighted_score = score * weight) %>% 
    group_by(id_student) %>% 
    summarize(mean_weighted_score = mean(weighted_score, na.rm = TRUE))

```

Last, we will create a socioeconomic status variable (`imd_band`) outside the recipe for clarity:

```{r}
students <- students %>%
    mutate(imd_band = factor(imd_band, levels = c("0-10%",
                                                  "10-20%",
                                                  "20-30%",
                                                  "30-40%",
                                                  "40-50%",
                                                  "50-60%",
                                                  "60-70%",
                                                  "70-80%",
                                                  "80-90%",
                                                  "90-100%"))) %>%
    mutate(imd_band = as.factor(imd_band))
```

In the OULAD documentation, this is called the VLE (virtual learning environment) data source. Please review the description of the variables in the *studentVLE* and *VLE* sources (which are joined together for this learning lab) [here](https://analyse.kmi.open.ac.uk/open_dataset#description).

Let's import it:

```{r}
interactions <- read_csv("data/ml/oulad-interactions-filtered.csv") # need to unzip
```

#### [Your Turn]{style="color: green;"} â¤µ

*First*, `count()` the `activity_type` variable and *sort* the resulting output by frequency.

```{r}
interactions %>% 
    count(activity_type)
```

What does this tell you? Consulting the codebook and your output, please add at least two notes on what you are noticing:

Then, let's create a histogram of the `date` variable.

```{r}
interactions %>% 
    ggplot(aes(x = date)) +
    geom_histogram()
```

Let's join the data together.

```{r}
students <- students %>% 
    left_join(assessments_joined, by = "id_student")
```


Next, we'll load a new file --- one with *interactions* (or log-trace) data.

We have to do the same processing we did in the second learning lab, to obtain cut-off dates. As a reminder, the purpose of this is to train the model on data from the first one-third of the class, with the reasoning being this is a good time to intervene--far enough into the class to make an appreciable impact, but not too late to have a limited chance of being able to change students' trajectory in the class.

We'll repeat the procedure we carried out with the assessments data --- calculating a cut-off for each class and then filtering the data based upon this cut-off. But, since we've already done this for the assessment data, to allow us to focus more on the modeling, we are providing you with the already-filtered interactions data.

Next, we load `oulad-interactions-filtered.csv` into R, assigning the resulting data frame the name `interactions`.

#### [Your Turn]{style="color: green;"} â¤µ

```{r}
interactions <- read_csv("data/ml/oulad-interactions-filtered.csv")

```

How can we create a feature with `sum_click`? Think back to our
discussion in the presentation; we have *many* options for working with
such time series data. Perhaps the most simple is to count the clicks.
Please summarize the number of clicks for each student (specific to a
single course). This means you will need to group your data by
`id_student`, `code_module`, and `code_presentation`, and then create a
summary variable.

```{r}
interactions_summarized <- interactions %>% 
    group_by(id_student, code_module, code_presentation) %>% 
    summarize(sum_clicks = sum(sum_click))

interactions_summarized
```

How many times did students click? Let's create a histogram to see.
Please use {ggplot} and `geom_histogram()` to visualize the distribution
of the `sum_clicks` variable you just created.

```{r}

interactions_summarized %>% 
    ggplot(aes(x = sum_clicks)) +
    geom_histogram()
```

This is a good start - we've created our first feature based upon the
log data, `sum_clicks`! What are some other features we can add? An affordance
of using the `summarize()` function in R is we can create multiple
summary statistics at once. Let's also calculate the standard deviation
of the number of clicks as well as the mean. Please copy the code you
wrote above into the code chunk below and then add these two additional
summary statistics.

```{r}
interactions_summarized <- interactions %>% 
    group_by(id_student, code_module, code_presentation) %>% 
    summarize(sum_clicks = sum(sum_click),
              sd_clicks = sd(sum_click), 
              mean_clicks = mean(sum_click))
```

Let's join together *all* of the data we'll use for
our modeling: `students` and `intteractions_summarized`. Use
`left_join()` once more, assigning the resulting output the name
`students_and_interactions`. 

Lots of joining! Sometimes, the hardest part of complex analyses lies in the preparation (and joining) of the data.

#### [Your Turn]{style="color: green;"} â¤µ

```{r}
students_and_interactions <- left_join(students, 
                                       interactions_summarized)
```

#### Step 2: Splitting the Data

We split the dataset into training and testing sets using an 80-20 split:

```{r}
set.seed(2025)

train_test_split <- initial_split(students_and_interactions, prop = 0.8, strata = "pass")

data_train <- training(train_test_split)
data_test  <- testing(train_test_split)
```

#### Step 3: Creating a Recipe for Selected Preprocessing Steps

To keep things simple, we will only include a few pre-processing steps.

```{r}
my_rec <- recipe(pass ~ disability + imd_band + mean_weighted_score + 
                     num_of_prev_attempts + gender + region + highest_education +
                     sum_clicks + 
                     sd_clicks +
                     mean_clicks,
                 data = data_train) %>%
    # steps
    step_impute_mean(mean_weighted_score, sum_clicks, sd_clicks, mean_clicks) %>%
    step_impute_mode(imd_band) %>% 
    step_center(mean_weighted_score) %>%
    step_scale(mean_weighted_score) %>%
    step_dummy(all_nominal_predictors(), -all_outcomes()) %>% 
    step_scale(num_of_prev_attempts)
```

We can inspect the recipe to verify the steps:

```{r}
my_rec
```

#### Step 4: Specifying the Model and Workflow

Next, we specify a logistic regression model and bundle the recipe and model into a workflow. This step has a lot of pieces, but they are fairly boilerplate. The first part is to specify the model:

```{r}
my_mod <- logistic_reg() %>% 
    set_engine("glm") %>% 
    set_mode("classification")

# my_mod <- boost_tree() %>%
#   set_engine("xgboost") %>%  # "xgboost" is a common engine for boosted trees
#   set_mode("classification")
```

The next is to specify the workflow.

```{r}
my_wf <- workflow() %>%
    add_recipe(my_rec) %>%
    add_model(my_mod)
```

#### Step 5: Fitting the Model

Now we fit the model to the training data. We do this by calling the `last_fit()` function on the workflow:

```{r}
final_fit <- last_fit(my_wf, train_test_split)
```

#### Step 6: Evaluating Model Performance

Finally, we evaluate the modelâ€™s performance using the test set. The tidymodels package makes this easy.

```{r}
metrics <- final_fit %>%
    collect_metrics()

metrics
```

So, how did the model do? Not so bad!

One affordance of tidymodels is we can readily switch out the model and engine. Try one of these modifications to the code to see how the predictive performance improves---for a random forest and a boosted tree model, respectively.

```{r, eval = FALSE}
my_mod <- rand_forest() %>%
    set_engine("ranger") %>% # install.packages("ranger") needed first
    set_mode("classification")

my_mod <- boost_tree() %>% # install.packages("xgboost") needed first
  set_engine("xgboost") %>% 
  set_mode("classification")
```

## Conclusion

Though we focus on this relatively simple model, or algorithm,, many of the ideas explored in this chapter will likely extend and prove useful for other machine learning methods. Our goal is for you to finish this final walkthrough with the confidence to explore using machine learning to answer a question or to solve a problem of your own with respect to teaching, learning, and educational systems.

In this chapter, we introduced general machine learning ideas, like training and test datasets and evaluating the importance of specific variables, in the context of predicting students' passing a course. Like many of the topics in this book---but, perhaps *particularly* so for machine learning---there is much more to discover on the topic, and we encourage you to consult the books and resources in the [Learning More chapter](#c17) to learn about further applications of machine learning methods.
