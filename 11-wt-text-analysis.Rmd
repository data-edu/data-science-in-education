# Walkthrough 5: Text analysis with social media data {#c11}

**Abstract**

This chapter explores tidying, transforming, visualizing, and analyzing text data. Data scientists in education are surrounded by text-based data sources like word processing documents, emails, and survey responses. Data scientists in education can expand their opportunities to learn about the student experience by adding text mining and natural language processing to their toolkit. Using Bluesky data, this chapter shows the reader practical tools for text analysis, including preparing text data, counting and visualizing words, and doing sentiment analysis. The chapter uses posts from #tidytuesday, an R learning community, to put these techniques in an education context. Data science tools in this chapter include transforming text into data frames, filtering datasets for keywords, running sentiment analysis and algorithms, and visualizing data.


## Topics emphasized

- Tidying data 
- Transforming data
- Visualizing data

## Functions introduced

- `sample_n()`
- `set.seed()`
- `tidytext::unnest_tokens()`
- `tidytext::get_sentiments()`
- `tidytext::inner_join()`

## Vocabulary 

- RDS files 
- Text analysis
- Stop words
- Tokenize 

## Chapter overview

The ability to work with many kinds of datasets is one of the great features of doing data science with programming. So far we've analyzed data in `.csv` files, but that's not the only way data is stored. If we can learn some basic techniques for analyzing text, we increase the number of places we can find information to learn about the student experience.

In this chapter, we focus on analyzing textual data from Bluesky. We focus on this particular data source because we think it is relevant to a number of educational topics and questions, including how newcomers learn to visualize data. In addition, Bluesky data is complex and includes not only information about who posted (and when---and a great deal of additional information (see [@bskyr])), but also the text of the post. This makes it especially well-suited for exploring the uses of text analysis, which is broadly part of a group of techniques involving the analysis of text as data---Natural Language Processing (often abbreviated NLP) [@hirschberg2015].

We note that while we focused on #tidytuesday because we think it exemplifies the new kinds of learning-related data that a data science toolkit allows an analyst to try to understand, we also chose this because it is straightforward to access data from Bluesky. While this chapter dives deeply into the analysis of the *text* of posts, [Chapter 12](#c12) explores both how to access this data and the nature of the interactions that take place between individuals through #tidytuesday.

### Background 

When we think about data science in education, our minds tends to go data stored in spreadsheets. But what can we learn about the student experience from text data? Take a moment to mentally review all the moments in your work day that you generated or consumed text data. In education, we're surrounded by it. We do our lessons in word processor documents, our students submit assignments online, and the school community expresses themselves on public social media platforms. The text we generate can be an authentic reflection of reality in schools, so how might we learn from it?

Even the most basic text analysis techniques will expand your data science toolkit. For example, you can use text analysis to count the number of key words that appear in open-ended survey responses. You can analyze word patterns in student responses or message board posts. 

Analyzing a collection of text is different from analyzing large numerical datasets because words don't have agreed upon values the way numbers do. The number 2 will always be more than 1 and less than 3. The word "fantastic", on the other hand, has multiple ambiguous levels of degree depending on interpretation and context. 

Using text analysis can help to broadly estimate what is happening in the text. When paired with observations, interviews, and close review of the text, this approach can help education staff learn from text data. In this chapter, we'll learn how to count the frequency of words in a dataset and associate those words with common feelings like positivity or joy. 

We'll show these techniques using a dataset of posts from Bluesky. We encourage you to complete the walkthrough, then reflect on how the skills learned can be applied to other texts, like word processing documents or websites.  

### Data source

It's useful to learn text analysis techniques from datasets that are available for download. Social media platforms provide rich sources of text data that can help us understand learning communities. Since there's so much data available, it's useful to narrow the posts to only those that help you answer your analytic questions. Hashtags are text within a post that act as a way to categorize content. Here's an example:

>I'm trying to recreate some Stata code in R, anyone have a good resource for what certain functions in Stata are doing? #RStats #Stata

Bluesky recognizes any words that start with a "#" as a hashtag. The hashtags "#RStats" and "#Stata" make this post conveniently searchable. If you search for "#RStats", Bluesky returns all the posts containing that hashtag.

In this example, we'll be analyzing a dataset of posts that have the hashtag #tidytuesday. #tidytuesday is a community sparked by the work of one of the *Data Science in Education Using R* co-authors, Jesse Mostipak, who created the (related) #r4ds community from which #tidytuesday was created. #tidytuesday is a weekly data visualization challenge. A great place to see examples from past #tidytuesday challenges is an interactive Shiny application (https://github.com/nsgrantham/tidytuesdayrocks).

The #tidytuesday hashtag returns posts about the weekly TidyTuesday practice, where folks learning R create and share data visualizations they made while learning to use tidyverse R packages. 

### Methods

In this walkthrough, we'll be using some simple methods -- counting words in a text dataset. Then we'll also use a more advanced technique called sentiment analysis to count and visualize the appearance of words that have a positive association. Lastly, we'll learn how to get more context by selecting random rows of posts for closer reading---or even a qualitative analysis.

## Load packages

For this analysis, we'll be using the {tidyverse} and {here} packages. We will also use the {tidytext} package for working with textual data [@R-tidytext]. As it has not been used previously in the book, you may need to install the {tidytext} package (and---if you haven't just yet---the other packages), first.
For instructions on and an overview about installing packages, see the ["Packages" section](#c06p) of the ["Foundational Skills"](#c06) chapter.

Let's load our packages before moving on to import the data:

```{r load packages, message = F, warning = F}
library(tidyverse)
library(tidytext)
```

## Import data

Let's start by getting the data into our environment so we can start analyzing it. In [Chapter 12](#c12), we describe how we accessed this data through Bluesky's Application Programming Interface, or API (and how you can access data from Bluesky on other hashtags or terms, too).

We've prepared a dataset of #tidytuesday posts from Bluesky. Let's start by reading in this dataset:

```{r read data}
# We will need to show how to do this with the {dataedu} package, I think - just need to swich out code below
# raw_posts <- dataedu::bluesky_posts
raw_posts <- read_rds("posts.rds")
```

## View data

Let's return to our `raw_posts` dataset. Run `glimpse(raw_posts)` and notice the variables in this dataset. It's good practice to use functions like `glimpse()` or `str()` to look at the data type of each variable. For this walkthrough, we'll need to extract the text from the nested data structure and create an identifier for each post. 

## Process data

In this section we'll extract the text and then we'll transform the dataset so each row represents a word. After that, our dataset will be ready for exploring.

First, we need to extract the text from the nested `record` structure. Each post's text is stored in `record$text`.

```{r pick columns}
posts <-
  raw_posts %>%
  mutate(post_id = row_number(),
         text = map_chr(record, ~pluck(.x, "text", .default = ""))) %>%
  filter(text != "") %>%
  select(post_id, text) %>%
  mutate(post_id = as.character(post_id))
```

Now the dataset has a column to identify each post and a column that shows the text that users posted. But each row has the entire post in the `text` variable, which makes it hard to analyze. If we kept our dataset like this, we'd need to use functions on each row to do something like count the number of times the word "good" appears. We can count words more efficiently if each row represented a single word. Splitting sentences in a row into single words in a row is called "tokenizing". In their book *Text Mining With R*, @silge2017text describe tokens this way:

>A token is a meaningful unit of text, such as a word, that we are interested in using for analysis, and tokenization is the process of splitting text into tokens. This one-token-per-row structure is in contrast to the ways text is often stored in current analyses, perhaps as strings or in a document-term matrix.

Let's use `unnest_tokens()` from the {tidytext} package to take our dataset of posts and transform it into a dataset of words.

```{r tokenize data}
tokens <-
  posts %>%
  unnest_tokens(output = word, input = text)

tokens
```

We use `output = word` to tell `unnest_tokens()` that we want our column of tokens to be called `word`. We use `input = text` to tell `unnest_tokens()` to tokenize the posts in the `text` column of our `posts` dataset. The result is a new dataset where each row has a single word in the `word` column and a unique ID in the `post_id` column that tells us which post the word appears in.

Notice that our `tokens` dataset has many more rows than our `posts` dataset. This tells us a lot about how `unnest_tokens()` works. In the `posts` dataset, each row has an entire post and its unique ID. Since that unique ID is assigned to the entire post, each unique ID only appears once in the dataset. When we used `unnest_tokens()` to put each word on its own row, we broke each post into many words. This created additional rows in the dataset. And since each word in a single post shares the same ID for that post, an ID now appears multiple times in our new dataset. 

We're almost ready to start analyzing the dataset! There's one more step we'll take---removing common words that don't help us learn what people are posting about. Words like "the" or "a" are in a category of words called "stop words". Stop words serve a function in verbal communication, but don't tell us much on their own. As a result, they clutter our dataset of useful words and make it harder to manage the volume of words we want to analyze. The {tidytext} package includes a dataset called `stop_words` that we'll use to remove rows containing stop words. We'll use `anti_join`() on our `tokens` dataset and the `stop_words` dataset to keep only rows that have words *not* appearing in the `stop_words` dataset. You'll also remove account names.

```{r remove stop words}
data(stop_words)

tokens <-
  tokens %>%
  anti_join(stop_words, by = "word") %>%
  filter(!str_detect(word, "\\.bsky\\.social$")) # removes account names from the words (tokens)
```

Why does this work? Let's look closer. `inner_join()` matches the observations in one dataset to another by a specified common variable. Any rows that don't have a match get dropped from the resulting dataset. `anti_join()` does the same thing as `inner_join()` except it drops matching rows and keeps the rows that *don't* match. This is convenient for our analysis because we want to remove rows from `tokens` that contain words in the `stop_words` dataset. When we call `anti_join()`, we're left with rows that *don't* match words in the `stop_words` dataset. These remaining words are the ones we'll be analyzing.

One final note before we start counting words: Remember when we first tokenized our dataset and we passed `unnest_tokens()` the argument `output = word`? We conveniently chose `word` as our column name because it matches the column name `word` in the `stop_words` dataset. This makes our call to `anti_join()` simpler because `anti_join()` knows to look for the column named `word` in each dataset. 

## Analysis: counting words 

Now it's time to start exploring our newly cleaned dataset of posts. Computing the frequency of each word and seeing which words showed up the most often is a good start. You can pipe `tokens` to the `count` function to do this: 

```{r count words}
tokens %>% 
    count(word, sort = TRUE) 
```

You pass `count()` the argument `sort = TRUE` to sort the `n` variable from the highest value to the lowest value. This makes it easy to see the most frequently occurring words at the top. Not surprisingly, "tidytuesday" was the most frequent word in this dataset (we may wish to remove it given that our search was based on it!).

You may want to explore further by showing the frequency of words as a percent of the whole dataset. Calculating percentages like this is useful in a lot of education scenarios because it helps us make comparisons across different sized groups. For example, you may want to calculate what percentage of students in each classroom receive special education services. 

In our posts dataset, you'll be calculating the count of words as a percentage of all posts. We can do that by using `mutate()` to add a column called `percent`. `percent` will divide `n` by `sum(n)`, which is the total number of words. Finally, will multiply the result by 100.

```{r count words as percentage}
tokens %>%
  count(word, sort = TRUE) %>%
  # n as a percent of total words
  mutate(percent = n / sum(n) * 100)
```

Even at 622 appearances in our dataset, "tidytuesday" represents only about 6% of the total words in our dataset. This makes sense when you consider our dataset contains thousands (2,963, specifically) unique words. 

## Analysis: sentiment analysis

Now that you have a sense of the most frequently appearing words, it's time to explore some questions in our posts dataset. Let's imagine that we're education consultants trying to learn about the community surrounding the TidyTuesday data visualization ritual. We know from the first part of our analysis that the token "dataviz" (a short name for data visualization) appeared frequently relative to other words, so maybe we can explore that further. A good start would be to see how the appearance of that token in a post is associated with other positive words. 

You'll need to use a technique called "sentiment analysis" to get at the "positivity" of words in these posts. Sentiment analysis tries to evaluate words for their emotional association. If we analyze words by the emotions they convey, we can start to explore patterns in large text datasets like our `tokens` data. 

Earlier you used `anti_join()` to remove stop words in our dataset. You're going to do something similar here to reduce our `tokens` dataset to only words that have a positive association. We'll use a dataset called the "NRC Word-Emotion Association Lexicon" to help us identify words with a positive association. This dataset was published in a work called *Crowdsourcing a Word-Emotion Association Lexicon* [@mohammad2013]

You need to install a package called {textdata} to make sure we have the NRC Word-Emotion Association Lexicon dataset available to us. Note that you only need to have this package installed. You do not need to load it with the `library(textdata)` command. 

If you don't already have it, let's install {textdata}: 

```{r install textdata, eval=FALSE}
install.packages("textdata")
```

To explore this dataset more, we'll use a {tidytext} function called `get_sentiments()` to view some words and their associated sentiment. If this is your first time using the NRC Word-Emotion Association Lexicon, you'll be prompted to download the NRC lexicon. Respond "yes" to the prompt and the NRC lexicon will download. Note that you'll only have to do this the first time you use the NRC lexicon. 

```{r read nrc}
#| include: false
nrc_sentiments <- read_rds("data/nrc_sentiments.Rds")
```

```{r view nrc}
#| eval: false
nrc_sentiments <- get_sentiments("nrc")
```

This returns a dataset with two columns. The first is `word` and contains a list of words. The second is the `sentiment` column, which contains an emotion associated with each word. This dataset is similar to the `stop_words` dataset. Note that this dataset also uses the column name `word`, which will again make it easy for us to match this dataset to our `tokens` dataset. 

### Count positive words

Let's begin working on reducing our `tokens` dataset down to only words that the NRC dataset associates with positivity. We'll start by creating a new dataset, `nrc_pos`, which contains the NRC words that have the positive sentiment. Then we'll match that new dataset to `tokens` using the `word` column that is common to both datasets. Finally, we'll use `count()` to total up the appearances of each positive word. 

```{r count positive words}
# Only positive in the NRC dataset
nrc_pos <-
    nrc_sentiments %>%
    filter(sentiment == "positive")

# Match to tokens
pos_tokens_count <-
  tokens %>%
  inner_join(nrc_pos, by = "word") %>%
  # Total appearance of positive words
  count(word, sort = TRUE) 

pos_tokens_count
```

You can visualize these words nicely by using {ggplot2} to show the positive words in a bar chart. There are 213 positive words total, which is hard to convey in a compact chart. You'll solve that problem by filtering our dataset to only words that appear 5 times or more. 

```{r fig11-1, results='hide', message = FALSE, fig.cap="Count of Words Associated with Positivity", fig.showtext = TRUE}
pos_tokens_count %>%
  filter(n >= 5) %>%
  ggplot(., aes(x = reorder(word, -n), y = n)) +
  geom_bar(stat = "identity", fill = "darkblue") +
  labs(
    title = "Count of Words Associated with Positivity",
    subtitle = "Posts with the hashtag #tidytuesday",
    caption = "Data: Bluesky and NRC",
    x = "",
    y = "Count"
  ) +
  theme_minimal()
```

Note the use of `reorder()` when mapping the `word` variable to the x aesthetic. Using `reorder()` here sorts our x-axis in descending order by the variable `n`. Sorting the bars from highest frequency to lowest makes it easier for the reader to identify and compare the most and least common words in the visualization. 

### "Dataviz" and other positive words

Earlier in the analysis we learned that "dataviz" was among the most frequently occurring words in this dataset. We can continue our exploration of TidyTuesday posts by seeing how many posts with "dataviz" also had at least one positive word from the NRC dataset. Looking at this might give us some clues about how people in the TidyTuesday learning community view dataviz as a tool.

There are a few steps to this part of the analysis, so let's review our strategy. We'll need to use the `post_id` field in the `posts` dataset to filter the posts that have the word `dataviz` in them. Then we need to use the `post_id` field in this new bunch of `dataviz` posts to identify the posts that include at least one positive word.

How do you know which `post_id` values contain the word "dataviz" and which ones contain a positive word? Recall that our `tokens` dataset only has one word per row, which makes it easy to use functions like `filter()` and `inner_join()` to make two new datasets: one of `post_id` values that have "dataviz" in the `word` column and one of `post_id` values that have a positive word in the `word` column.

You'll explore the combinations of "dataviz" and any positive words in our `posts` dataset using these three ingredients: our `posts` dataset, a vector of `post_id`s for posts that have "dataviz" in them, and a vector of `post_id`s for posts that have positive words in them. Now that we have our strategy, let's write some code and see how it works.

First, you'll make a vector of `post_id`s for posts that have "dataviz" in them. This will be used later to identify posts that contain "dataviz" in the text. We'll use `filter()` on our `tokens` dataset to keep only the rows that have "dataviz" in the `word` column. Let's name that new dataset `dv_tokens`. 

```{r post_id with dataviz}
dv_tokens <-
  tokens %>%
  filter(word == "dataviz")

dv_tokens
```

The result is a dataset that has `post_id` in one column and the word "dataviz" in the other column. We can use `$` to extract a vector of `post_id` for posts that have "dataviz" in the text. This vector has hundreds of values, so we'll use `head` to view just the first ten.

```{r just post_id}
# Extract post_id
head(dv_tokens$post_id)
```

Now let's do this again, but this time, we'll make a vector of `post_id` for posts that have positive words in them. This will be used later to identify posts that contain a positive word in the text. We'll use `filter()` on our `tokens` dataset to keep only the rows that have any of the positive words in the in the `word` column. If you've been running all the code up to this point in the walkthrough, you'll notice that you already have a dataset of positive words called `nrc_pos`, which can be turned into a vector of positive words by typing `nrc_pos$word`. We can use the `%in%` operator in our call to `filter()` to find only words that are in this vector of positive words. Let's name this new dataset `pos_tokens`.

```{r post_id with positive words}
pos_tokens <-
  tokens %>%
  filter(word %in% nrc_pos$word)

pos_tokens
```

The result is a dataset that has `post_id` in one column and a positive word from `tokens` in the other column. We'll again use `$` to extract a vector of `post_id` for these posts.

```{r just post_id 2}
# Extract post_id
head(pos_tokens$post_id)
```

That's a lot of `post_id`s, many of which are duplicates. Let's try and make the vector of `post_id`s a little shorter. We can use `distinct()` to get a data frame of `post_id`, where each `post_id` only appears once:

```{r using distinct}
pos_tokens <-
  pos_tokens %>%
  distinct(post_id)
```

Note that `distinct()` drops all variables except for `post_id`. For good measure, let's use `distinct()` on our `dv_tokens` data frame too:

```{r using distinct 2}
dv_tokens <-
  dv_tokens %>%
  distinct(post_id)
```

Now we have a data frame of `post_id` for posts containing "dataviz" and another for posts containing a positive word. Let's use these to transform our `posts` dataset. First we'll filter `posts` for rows that have the "dataviz" `post_id`. Then we'll create a new column called `positive` that will tell us if the `post_id` is from our vector of positive word `post_id`s. We'll name this filtered dataset `dv_pos`.

```{r dataviz posts with positive variable}
dv_pos <-
  posts %>%
  # Only posts that have the dataviz post_id
  filter(post_id %in% dv_tokens$post_id) %>%
  # Is the post_id from our vector of positive word?
  mutate(positive = if_else(post_id %in% pos_tokens$post_id, 1, 0))
```

Let's take a moment to dissect how we use `if_else()` to create our `positive` column. We gave `if_else()` three arguments:

 - `post_id %in% pos_tokens$post_id`: a logical statement
 - `1`: the value of `positive` if the logical statement is true
 - `0`: the value of `positive` if the logical statement is false

So our new `positive` column will take the value 1 if the `post_id` was in our `pos_tokens` dataset and the value 0 if the `post_id` was not in our `pos_tokens` dataset. Practically speaking, `positive` is 1 if the post has a positive word and 0 if it does not have a positive word.

And finally, let's see what percent of posts that had "dataviz" in them also had at least one positive word:

```{r percent that had a positive word}
dv_pos %>%
  count(positive) %>%
  mutate(perc = n / sum(n))
```

About 41% of posts that have "dataviz" in them also had at least one positive word, and about 59% of them did not have at least one positive word. It's worth noting here that this finding doesn't necessarily mean users didn't have anything good to say about 59% of the "dataviz" posts. We can't know precisely why some posts had positive words and some didn't, we just know that more dataviz posts had positive words than not. To put this in perspective, we might have a different impression if 5% or 95% of the posts had positive words. 

Since the point of exploratory data analysis is to explore and develop questions, let's continue to do that. In this last section we'll review a random selection of posts for context.

### Taking a close read of randomly selected posts

Let's review where we are so far as we work to learn more about the TidyTuesday learning community through posts. So far we've counted frequently used words and estimated the number of posts with positive associations. This dataset is large, so we need to zoom out and find ways to summarize the data. But it's also useful to explore by zooming in and reading some of the posts. Reading posts helps us to build intuition and context about how users talk about TidyTuesday in general. Even though this doesn't lead to quantitative findings, it helps us to learn more about the content we're studying and analyzing. Instead of reading all the posts, let's write some code to randomly select posts to review.

First, let's make a dataset of posts that had positive words from the NRC dataset. Remember earlier when we made a dataset of posts that had "dataviz" and a column that had a value of 1 for containing positive words and 0 for not containing positive words? Let's reuse that technique, but instead of applying to a dataset of posts containing "dataviz", let's use it on our dataset of all posts.

```{r positive posts}
pos_posts <-
  posts %>%
  mutate(positive = if_else(post_id %in% pos_tokens$post_id, 1, 0)) %>%
  filter(positive == 1)
```

Again, we're using `if_else` to make a new column called `positive` that takes its value based on whether `post_id %in% pos_tokens$post_id` is true or not.

We can use `slice()` to help us pick the rows. When we pass `slice()` a row number, it returns that row from the dataset. For example, we can select the 1st and 3rd row of our posts dataset this way:

```{r first and third post}
posts %>%
  slice(1, 3)
```

Randomly selecting rows from a dataset is great technique to have in your toolkit. Random selection helps us avoid some of the biases we all have when we pick rows to review ourselves.

Here's one way to do that using base R:

```{r}
sample(x = 1:10, size = 5)
```

Passing `sample()` a vector of numbers and the size of the sample you want returns a random selection from the vector. Try changing the value of `x` and `size` to see how this works.

{dplyr} has a version of this called `sample_n()` that we can use to randomly select rows in our posts dataset. Using `sample_n()` looks like this:

```{r randomly review}
set.seed(2026)

pos_posts %>%
  sample_n(., size = 10)
```

That returned ten randomly selected posts that we can now read through and discuss. Let's look a little closer at how we did that. We used `sample_n()`, which returns randomly selected rows from our posts dataset. We also specified that `size = 10`, which means we want `sample_n()` to give us 10 randomly selected rows. A few lines before that, we used `set.seed(2026)`. This helps us ensure that, while `sample_n()` theoretically plucks 10 random numbers, our readers can run this code and get the same result we did. Using `set.seed(2026)` at the top of your code makes `sample_n()` pick the same ten rows every time. Try changing `2026` to another number and notice how `sample_n()` picks a different set of ten numbers, but repeatedly picks those numbers until you change the argument in `set.seed()`. 

## Conclusion

The purpose of this walkthrough is to share code with you so you can practice some basic text-analysis techniques. Now it's time to make your learning more meaningful by adapting this code to text-based files you regularly see at work. Trying reading in some of these and doing a similar analysis:

 - News articles
 - Procedure manuals
 - Open-ended responses in surveys

There are also advanced text analysis techniques to explore. Consider trying topic modeling (https://www.tidytextmining.com/topicmodeling.html) or finding correlations between terms (https://www.tidytextmining.com/ngrams.html), both described in [@silge2017text].

Finally, if you feel like there is more to analyze where it comes to this particular hashtag, we agree! We use this data set further in the next chapter [on social network analysis](#c12), where we explore how to collect your own Bluesky data and analyze the interactions between individuals in the #tidytuesday community.